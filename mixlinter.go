package mixlinter

import (
	"flag"
	"fmt"
	"go/ast"
	"go/build"
	"go/parser"
	"go/token"
	"golang.org/x/tools/go/analysis"
	"golang.org/x/tools/go/analysis/passes/inspect"
	"golang.org/x/tools/go/ast/inspector"
	"path/filepath"
	"reflect"
	"strings"
)

var includeTest bool
var includeProtocolBufferGenerated bool

func init() {
	Analyzer.Flags.BoolVar(&includeTest, "include test file", false, "include test file or not")
	Analyzer.Flags.BoolVar(&includeProtocolBufferGenerated, "include generated by protocol buffer file", false, "include generated by protocol buffer file")
}

var Analyzer = &analysis.Analyzer{
	Name: "mixlinter",
	Doc:  Doc,
	Run:  run,
	Requires: []*analysis.Analyzer{
		inspect.Analyzer,
	},
	Flags: flag.FlagSet{
		Usage: nil,
	},
}

const Doc = "mixlinter is ..."

func run(pass *analysis.Pass) (interface{}, error) {
	ins := pass.ResultOf[inspect.Analyzer].(*inspector.Inspector)

	nodeFilter := []ast.Node{
		(*ast.CompositeLit)(nil),
	}

	ins.Preorder(nodeFilter, func(nd ast.Node) {
		fileDirList := strings.Split(pass.Fset.File(nd.Pos()).Name(), "/")
		fileName := fileDirList[len(fileDirList)-1]
		if strings.HasPrefix(fileName, "mock_") {
			return
		}
		if !includeTest && strings.HasSuffix(fileName, "_test.go") {
			return
		}
		if !includeProtocolBufferGenerated && strings.HasSuffix(fileName, ".pb.go") {
			return
		}

		var keySet bool
		switch n := nd.(type) {
		case *ast.CompositeLit:
			var fields []string
			var setFields []string

			if reflect.ValueOf(n).IsNil() {
				return
			}

			// pkg外
			if se, ok := n.Type.(*ast.SelectorExpr); ok {

				f, err := parser.ParseFile(token.NewFileSet(), pass.Fset.File(nd.Pos()).Name(), nil, 0)
				if err != nil {
					fmt.Printf("pkg out Failed to parse file: %s\n", err)
					return
				}

				for _, imp := range f.Imports {
					xList := strings.Split(strings.Trim(imp.Path.Value, `"`), "/")
					x := xList[len(xList)-1]

					gopath := build.Default.GOPATH
					if x == fmt.Sprintf("%s", se.X) {
						fl, err := parser.ParseDir(token.NewFileSet(), filepath.Join(gopath, "src", strings.Trim(imp.Path.Value, `"`)), nil, 0)
						if err != nil {
							fmt.Printf("parse err:%+v\n", err)
							return
						}

						for _, f := range fl {
							ast.Inspect(f, func(node ast.Node) bool {
								genDecl, ok := node.(*ast.GenDecl)
								if !ok {
									return true
								}
								for _, spec := range genDecl.Specs {
									typeSpec, ok := spec.(*ast.TypeSpec)
									if !ok {
										continue
									}
									if st, ok := typeSpec.Type.(*ast.StructType); ok {
										if typeSpec.Name.Name != se.Sel.Name {
											continue
										}
										for _, f := range st.Fields.List {
											if len(f.Names) == 0 {
												switch t := f.Type.(type) {
												case *ast.SelectorExpr:
													fields = append(fields, t.Sel.Name)
												}
											} else {
												switch f.Type.(type) {
												case *ast.Ident:
													fields = append(fields, f.Names[0].Name)
												}
											}
										}
									}
								}
								return true
							})
						}
					}
				}
			}

			// pkgない
			if ident, ok := n.Type.(*ast.Ident); ok {
				if reflect.ValueOf(ident.Obj).IsNil() || reflect.ValueOf(ident.Obj.Decl).IsNil() {
					// 同一ファイル外
					fl, err := parser.ParseDir(token.NewFileSet(), strings.Join(fileDirList[0:len(fileDirList)-1], "/"), nil, 0)
					if err != nil {
						fmt.Printf("Failed to parse file\n")
						return
					}
					for _, f := range fl {
						ast.Inspect(f, func(node ast.Node) bool {
							genDecl, ok := node.(*ast.GenDecl)
							if !ok {
								return true
							}
							for _, spec := range genDecl.Specs {
								typeSpec, ok := spec.(*ast.TypeSpec)
								if !ok {
									continue
								}
								if st, ok := typeSpec.Type.(*ast.StructType); ok {
									if typeSpec.Name.Name != ident.Name {
										continue
									}
									for _, f := range st.Fields.List {
										if len(f.Names) == 0 {
											switch t := f.Type.(type) {
											case *ast.SelectorExpr:
												fields = append(fields, t.Sel.Name)
											}
										} else {
											switch f.Type.(type) {
											case *ast.Ident:
												fields = append(fields, f.Names[0].Name)
											}
										}
									}
								}
							}
							return true
						})
					}
				} else {
					if ts, ok := ident.Obj.Decl.(*ast.TypeSpec); ok {
						if st, ok := ts.Type.(*ast.StructType); ok {
							for _, f := range st.Fields.List {
								if len(f.Names) == 0 {
									switch t := f.Type.(type) {
									case *ast.SelectorExpr:
										fields = append(fields, t.Sel.Name)
									}
								} else {
									switch f.Type.(type) {
									case *ast.Ident:
										fields = append(fields, f.Names[0].Name)
									}
								}
							}
						}
					}
				}
			}

			for _, k := range n.Elts {
				switch e := k.(type) {
				case *ast.KeyValueExpr:
					keySet = true
					if ident, ok := e.Key.(*ast.Ident); ok {
						setFields = append(setFields, ident.Name)
					}
				default:
					setFields = append(setFields, "")
				}
			}
			if !keySet && len(setFields) != 0 {
				return
			}
			for _, f := range fields {
				if !contain(f, setFields) {
					pass.Reportf(n.Pos(), "uninitialised field found: %+v", f)
				}
			}
		}
	})

	return nil, nil
}

func contain(s string, sl []string) bool {
	for _, v := range sl {
		if s == v {
			return true
		}
	}
	return false
}
